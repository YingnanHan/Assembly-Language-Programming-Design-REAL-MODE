;AA:
;	db 0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
;BB:
;	db 0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
;CC:
;	db 0x33,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00


;上述代码的简便写法如下

jmp near Code	;根据以下原理jmp会一次性跳过16byte


section Data1 align=16 vstart=0	;使用section标号来定义一个段 段的名字是Data1 段的大小是16的倍数，如果不够那么使用0来补充
	AA:
		db 0x11	;0x0010 align是相对于前面来补充的。如果这里有17个字节的数据，那么就自动将AA段补充为下一个16的倍数32，补充的数字是0

section Data2 align=16 vstart=0
	BB:
		db 0x22 ;0x0020

section Data3 align=16 vstart=0;值得注意的是 如果加上了vstart语句下面的代码只要没有声明是那个段，那么就默认为实力他最近的上面的那个段，所以在定位地址的时候就会出现错误
	CC:		       ;解决此问题,就需要再次定义一个代码段并且不附加vstart,使得代码一开始的跳转指令可以跳转到确实的代码段
		db 0x33 ;0x0030

section Code align=16

Code:
	;
	mov ax,section.Data1.start
	mov ax,section.Data2.start
	mov ax,section.Data3.start


	mov ax,AA
	mov ax,BB
	mov ax,CC
;一般来说希望我们的相对段地址下面的标号AA，BB，CC在各自所属段中的起始地址是0
;也就是说在段内的偏移地址是从0开始的，所以这里加上伪指令 vstart=0,表示，在某一个段内
;引用标号的时候，该标号的汇编地址是从0开始算的

;标号AA的内存段地址是0x07C00
;标号BB的内存段地址是0x07C01
;标号CC的内存段地址是0x07C02

;0x11我希望它的段地址是:0x07C0:0x0000
;0x22我希望它的段地址是:0x07C1:0x0000
;0x33我希望它的段地址是:0x07C2:0x0000